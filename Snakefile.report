#!/bin/bash
# vim: ft=python

# Contents >>>
#   + Embedded BASH script to bootstrap the workflow
#   + Initialisation and configuration
#   + Helper functions
#   + The rules specific to this workflow
#   + More generic rules

# Note this workflow is designed to run locally. All of the heavy lifting should
# have been done by Snakefile.process_cells. It's vaguely useful to have locking here
# as we might possibly try to make 2 interim reports at once (in which case, just let
# one fail).

"""true" ### Begin shell script part
set -u

source "`dirname $0`"/shell_helper_functions.sh

export TOOLBOX="$(find_toolbox)"
export TEMPLATES="$(find_templates)"
export PATH="${PATH}:$(dirname "$0")"

snakerun_single "$0" "$@"

"exit""" ### End of shell script part
#!/usr/bin/env snakemake
from snakemake.utils import format
from smrtino import glob, load_yaml

TOOLBOX = 'env PATH="{}:$PATH"'.format(os.environ['TOOLBOX'])

""" Report will be made based upon all the .info.yaml files found. There may be none.
    For every .info.yaml we need to generate a corresponding .link.yaml, and
    we're also adding in PDF reports from SMRTLink at this stage - other plots are
    generated by Snakefile.process_cells and linked in the info.yaml files.
    Also we may or may not have some plots to add.
"""
def scan_cells(filter_by_config=True):
    """ Work out all the cells to process based on config['cells'].
        If supplied, config['cells'] will be a string like "1_A01 2_B01 3_C01" so
        we need to translate these to cell names.
    """
    all_info = [ load_yaml(y) for y in glob("*.info.yaml") ]

    if filter_by_config and ('cells' in config):
        all_info = [ y for y in all_info
                     if y['run_slot'] in config['cells'].split() ]

    return [ (y['run_slot'], y['cell_id']) for y in all_info ]


# Global wildcard patterns
wildcard_constraints:
    cellslot   = r"\d_[A-Z]01",
    cell       = r"m\w+_\w+_\w+",

# We shall make a single report per cell (used to be one per run).
# The report filenames are to be of the form:
#   {cellslot}_{cellid}.html
localrules: report_main
rule report_main:
    input:
        pan   = lambda wc: expand("all_reports/{c[0]}-{c[1]}.html", c=scan_cells()),
        plist = "projects_ready.txt",

# A list of projects, like with Illuminatus. Used to quickly scan for runs that have data related to
# a project. If there is no valid project name we still want a report but it should be clear there is
# a problem.
localrules: list_projects
rule list_projects:
    output: "projects_ready.txt"
    input:  lambda wc: expand("{c[1]}.info.yaml", c=scan_cells(False))
    priority: 100
    run:
        plist = set()
        for y in input:
            try:
                plist.add(load_yaml(y)['ws_project'])
            except KeyError:
                logger.error("No ws_project in {} - indicates no 5-digit project name found in readset XML".format(y))
        with open(output[0], "w") as ofh:
            print( *sorted(plist), file=ofh, sep='\n' )

# Note this script relies on ~/.smrtlinkrc for connection deets.
localrules: link_to_smrtlink, smrtlink_pdf_report
rule link_to_smrtlink:
    output: "{cell}.link.yaml"
    input:  "{cell}.info.yaml"
    shell:
        "link_to_smrtlink.py {input} > {output}"

# As does this, which will trigger generation of a new report, poll until ready, then
# download it.
# Modified to proceed even if report generation fails, since some datasets don't get
# properly imported in SMRTLink.
rule smrtlink_pdf_report:
    output: "all_reports/pdf/{cell}.pdf"
    input:  "{cell}.link.yaml"
    run:
        # Setting SMRTLINKRC_SECTION=none will cause an empty report file to be made
        cell_uuid = load_yaml(str(input))['cell_uuid']
        shell("smrtlink_pdf_report.py -o {output} --empty_on_missing {cell_uuid}")

# Invokes PanDoc with the template stuff
rule pan_to_html:
    output: "all_reports/{report}.html"
    input:  "all_reports/pandoc/{report}.pan"
    params:
        templates = os.environ.get('TEMPLATES', '.')
    shell:
       r"""{TOOLBOX} pandoc -f markdown \
                                --template={params.templates}/template.html \
                                --include-in-header={params.templates}/javascript.js.html \
                                --include-in-header={params.templates}/local.css.html \
                                --toc --toc-depth=2 \
                                -o {output} {input}
        """

# This rule marshalls all the .png images and makes one report in PanDoc format.
rule make_report:
    output:
        pan        = "all_reports/pandoc/{cellslot}-{cell}.pan",
        btouch     = touch("all_reports/img/{cellslot}-{cell}-blob.linked"),
    input:
        yaml       = "{cell}.info.yaml",
        links      = "{cell}.link.yaml",
        pdf        = "all_reports/pdf/{cell}.pdf",
        blob_plots = lambda wc: glob(f"blob/{wc.cell}.*.cov0*.png"),
    params:
        pdflink    = "pdf/{cell}.pdf",
    shell:
       r"""rm -vf all_reports/img/{wildcards.cell}.*.cov0*.png
           ln -vsrnt all_reports/img {input.blob_plots}
           make_report.py -o {output.pan} \
                -y {input.yaml} -l {input.links} -r {params.pdflink} \
                -s <(pb_run_status.py)
        """
