#!/bin/bash
# vim: ft=python

# Contents >>>
#   + Embedded BASH script to bootstrap the workflow
#   + Initialisation and configuration
#   + Helper functions
#   + The rules specific to this workflow
#   + More generic rules

# Note this workflow is designed to run locally. All of the heavy lifting should
# have been done by Snakefile.process_cells. It's vaguely useful to have locking here
# as we might possibly try to make 2 interim reports at once (in which case, just let
# one fail).

"""true" ### Begin shell script part
set -u

source "`dirname $0`"/shell_helper_functions.sh

export TOOLBOX="$(find_toolbox)"
export TEMPLATES="$(find_templates)"
export PATH="${PATH}:$(dirname "$0")"

snakerun_single "$0" "$@"

"exit""" ### End of shell script part
#!/usr/bin/env snakemake
import yaml
from snakemake.utils import format
from smrtino import glob

TOOLBOX = 'env PATH="{}:$PATH"'.format(os.environ['TOOLBOX'])

""" Report will be made based upon all the .info.yml files found. There may be none.
    For every .info.yml we need to generate a corresponding .link.yml
    Also we may or may not have some plots to add.
"""
INFO_YML = glob("*.info.yml")
LINK_YML = [ re.sub(r'\.info\.yml$', r'.link.yml', f) for f in INFO_YML ]

# We shall make a single report for the whole run. This is supposed to be fairly simple.
# If it gets complex we might need a more sophisticated report making strategy.
rule report_main:
    output: "all_reports/run_report.html"
    input:
        pan   = "all_reports/run_report.{cc}cells.pan".format(cc=len(INFO_YML))
    params:
        templates = os.environ.get('TEMPLATES', '.')
    shell:
        '''{TOOLBOX} pandoc -f markdown \
                                --template={params.templates}/template.html \
                                --include-in-header={params.templates}/javascript.js.html \
                                --include-in-header={params.templates}/local.css.html \
                                --toc --toc-depth=4 \
                                -o {input.pan}.html {input.pan}
           ln -sr {input.pan}.html {output}
        '''

# A list of projects, like with Illuminatus. Used to quickly scan for runs that have data related to
# a project. If there is no valid project name we still want a report but it should be clear there is
# a problem.
localrules: list_projects
rule list_projects:
    output: "projects_ready.txt"
    input: INFO_YML
    priority: 100
    run:
        plist = set()
        for y in input:
            with open(y) as yfh:
                try:
                    plist.add(yaml.safe_load(yfh)['ws_project'])
                except KeyError:
                    logger.error("No ws_project in {} - indicates no 5-digit project name found in readset XML".format(y))
        with open(output[0], "w") as ofh:
            print( *sorted(plist), file=ofh, sep='\n' )

# Note this script relies on ~/.smrtlinkrc for connection deets.
localrules: link_to_smrtlink
rule link_to_smrtlink:
    input:  "{cell}.info.yml"
    output: "{cell}.link.yml"
    shell:
        "link_to_smrtlink.py {input} > {output}"

# This rule marshalls all the .png images and makes the report in PanDoc format.
# Note - the run_status is now fudged so that the report says 'complete' when
# the run is complete, even though it's not complete (according to pb_run_status.py)
# as this script runs.
rule make_report:
    output: "all_reports/run_report.{cc}cells.pan"
    input:
        yaml = INFO_YML,
        links = LINK_YML,
        blob_plots = glob("blob/*.png"),
        histo_plots = glob("histo/*.png"),
        plist = "projects_ready.txt",
    params:
        fudge = "--fudge {rep_status}".format(**config) if config.get('rep_status') else ""
    shell:
        '''shopt -s nullglob
           rm -rf all_reports/img
           mkdir all_reports/img
           ln -srnt all_reports/img blob/*.png || true
           ln -srnt all_reports/img histo/*.png || true
           make_report.py -o {output} {params.fudge} -s <(pb_run_status.py) {input.yaml} {input.links}
        '''

